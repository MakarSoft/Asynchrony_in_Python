Как не существует универсального лекарства против всех болезней, так не существует универсальной концепции для эффективного решения любых задач в программировании. Для каждого типа задач подходит свой инструмент.

Как Вы знаете, любое выполнение программы — это последовательное выполнение инструкций на процессоре. Инструкции арифметики, логики, сравнения выполняются очень быстро. Однако в процессе выполнения процессору приходится также  обращаться к внешним устройствам — оперативной памяти, жесткому диску, устройствам ввода-вывода. Все они работают очень медленно с точки зрения процессора, что приводит к его простаиванию.

С этой точки зрения все задачи, которые выполняет программный код, разделяются на два типа:

- задачи, **большую часть времени нагружающие центральный процессор**.
Все виды расчетных операций, сравнения, преобразования, так называемые "числодробилки". Скорость выполнения таких задач прямо зависит от производительности процессора. Их так и называют CPU-bound операции (операции, зависящие, привязанные к ЦПУ);

- не расчетные задачи, которые **вместо интенсивной работы на процессоре, занимаются другими вещами**.
И спектр таких задач очень широк:
  - обращения/запросы/чтение/запись к внешним устройствам и контроллерам,
  - работа с файловой подсистемой,
  - работа с базами данных,
  - работа с устройствами хранения информации,
  - сетевые запросы.
  В общем, все остальные задачи, скорость выполнения которых определяется общим временем ожидания выполнения операций чтения/записи, которая в свою очередь складывается из пропускной способности канала, производительности шины, отзывчивости внешнего устройства, т.е. зависит от внешней относительно процессора подсистемы ввода-вывода. Соответственно, такие задачи называют **IO-bound операции** (зависящие, привязанные к Input Output - к вводу-выводу).

Здесь уже можно возразить, сказав что работа с процессором, как и собственно расчетные операции тоже включает в себя чтение и запись данных в кэш процессора. Так в чем разница? Разница в скорости. Ошеломительная разница в скорости.

Для  наглядности сравнения посмотрим на таблицу чтения данных с различных устройств.

| Устройство | Тактов ЦП   | Наглядная временная шкала |
| ---------- | ----------- | ------------------------- |
| Кэш L1     | 3           | 3 секунды                 |
| Кэш L2     | 14          | 14 секунд                 |
| ОЗУ        | 250         | 250 секунд                |
| HDD        | 41 000 000  | 1.3 года                  |
| Сеть       | 240 000 000 | 7.6 лет                   |

Процессор с гигагерцовой частой за одну секунду выполнит больше 300 миллионов операций чтения из кэша первого уровня, и за ту же секунду выполнятся всего 4 запроса по сети. Правая колонка позволяет наглядно сравнить операции чтения в привычной человеку системе координат. Как видим, здесь есть довольно резкая граница: работа процессора с кэшем и оперативной памятью и все остальное.

На практике большинство задач реальной бизнес логики, особенно с учетом развития микросервисной архитектуры и распределенных систем, выполняют преимущественно IO-bound операции. Приложения все больше зависят от обмена данными между различными компонентами, а общая производительность и отзывчивость определяются эффективностью решения проблем, связанных с обменом по сети, эффективностью работы с базами данных и т.п. Соответственно, эффективное управление этими операциями является критически важным аспектом проектирования программного обеспечения.

Глядя на таблицу вообще не хочется самому выполнять медленные IO операции, которые тормозят поток выполнения и блокируют его на время ожидания их завершения. Вот было бы здорово работать без ожиданий, делегируя все IO операции кому-нибудь другому, кто с этим хорошо справляется, а самим взаимодействовать только с процессором и оперативной памятью, своевременно обрабатывая результаты IO операций по мере их готовности.

---

```Python
import time
import requests

a = 10 + 20
print("Сейчас заблокируюсь на sleep и буду ждать")
time.sleep(2)
print("'Проснулся', продолжаю выполнение")

st_code = None
print("Сейчас заблокируюсь на сетевом запросе и буду ждать")
st_code = requests.get("https://ya.ru").status_code
print(f"Получил код ответа {st_code} на сетевой запрос, продолжаю выполнение")

print("Сейчас заблокируюсь на ожидание ввода в консоль и буду ждать")
input_data = input("Ожидаю ввода от пользователя: ")
print(f"Пользователь ввел {input_data}, продолжаю выполнение")

print("Сейчас заблокируюсь на время создания файла и/или получения доступа к нему")
try:
    file_obj = open("new_file.txt", "w", encoding="utf-8")
    print("А сейчас заблокируюсь на время, пока данные не будут записаны в файл")
    file_obj.write("Всегда лучше наблюдать за процессом, чем делать что-то самому")
finally:
    file_obj.close()
    print(f"Данные записаны, файловый объект закрыт, продолжаю выполнение")
print("Закончил работу")
```

Такой простой код почти полностью состоит из IO операций. Кроме первой арифметической инструкции, все стальные операции представляют из себя запросы к операционной системе "с просьбой":

- заблокировать выполнение программы на заданное количество секунд;
- выполнить сетевой запрос на указанный URL;
- запросить и получить что ввел пользователь в консоль;
- создать файл и открыть его;
- записать данные в открытый файл;
- закрыть файл.
Такие обращения к операционной системе называются **системными вызовами**. Во время системного вызова происходит блокирование выполнения нашей программы и передача управления операционной системе, а точнее ядру операционной системы. Такой механизм обеспечивает безопасный доступ к ресурсам операционной системы и железу: различным контроллерам и устройствам компьютера. Ядро выполняет запрошенное действие и после завершения, возвращает управление нашей программе. Таким образом каждая из инструкций в примере вообще-то является высокоуровневым интерфейсом к соответствующему низкоуровневому системному вызову.

Повторим еще раз эту важную часть. Когда программа выполняет системный вызов, она передает контроль операционной системе, которая выполняет необходимые операции и возвращает результат обратно программе, после чего программа возобновляет свою работу. Даже инструкция `print` является высокоуровневым интерфейсом к низкоуровневому системному вызову, который выполняет запись в поток вывода. Следует напомнить, что только IO операциями системные вызовы не ограничиваются. Через системные вызовы также создают процессы и потоки, управляют ими, работают с памятью и выполняют некоторые другие операции.

Кажется мы зашли в тупик. Чтобы взаимодействовать с подсистемой ввода-вывода мы обязательно должны обращаться к операционной системе через системные вызовы. Но тогда мы передаем контроль выполнения операционной системе и наша программа не продолжит свою работу, пока операционная система не вернет управление обратно вместе с результатом выполнения этого вызова. Что-то не похоже, чтобы здесь была лазейка, позволяющая сэкономить время. И это был бы действительно непреодолимый тупик, если бы операционные системы не поддерживали неблокирующие версии операций ввода-вывода. И сетевые операции и работа с файлами, включая запись и чтение, для всего этого есть варианты неблокирующего режима выполнения. В случае использования неблокирующего системного вызова, наша программа все равно потеряет управление, но операционная система вернет его очень быстро без ожидания полного завершения запрашиваемой операции чтения/записи.

Насколько быстро? Нам важна каждая доля секунды. Конечно, об оценке в секундах здесь речи не идет. Переключение управления в режим ядра и обратно в пользовательский режим можно оценить тактами процессора, мы так уже делали и такие данные есть. В среднем переход в режим ядра занимает **от 1000 до 1500 тактов**. Не самые большие цифры, но если часто использовать системные вызовы, даже в неблокирующем варианте, "намотает" все равно заметно. Вызывать в каком-нибудь цикле неблокирующий системный вызов на чтение файла пока, наконец, не удастся его прочитать — плохая идея, хоть и рабочая. К счастью, и здесь за нас уже все решили и все реализовали на уровне операционных систем. Оставим идею каких-то циклических системных неблокирующих запросов прочитать файл, теряя драгоценное время на переключение контекста. Вместо этого можно просто "попросить" операционную систему проследить за тем, когда файл будет готов для чтения (для чтения без блокирования). И когда ОС любезно сообщит нам об этом, мы без проблем и без лишних ожиданий прочитаем его. Этот механизм позволяет как бы подписаться на уведомление от операционной системы на завершение операций ввода-вывода. Мы можем попросить ОС контролировать множество файлов и запросить те из них, которые уже полностью готовы для чтения или записи для неблокирующего вызова `read` или `write`.

>наша программа может попросить ОС следить за файлом и сообщить нам, когда этот файл можно будет без проблем прочитать. Между просьбой и моментом готовности мы можем заниматься другими задачами. Когда ОС сообщит нам о готовности файла к чтению, мы его прочитаем без блокирования.

>Если попробовать сделать очень краткую выжимку одной фразой, то она, пожалуй, должна быть такой: ОС поддерживает неблокирующее выполнение IO операций и предоставляет механизмы для получения уже готовых результатов и обработки завершенных операций.

>А если еще короче: в асинхронном программировании без ОС никуда.

---

1. Процессор меняет контекст с пользовательского режима на режим ядра. В режиме ядра код выполняется с повышенными привилегиями и доступом ко всем системным ресурсам, включая доступ к железу: сетевые карты, контроллеры жестких дисков и т.д.
2. Выполняется требуемая операция системного вызова. Это может быть чтение/запись в файл, создание процесса, управление памятью и так далее.
3. После завершения вызова, процессор снова переключает контекст исполнения, возвращая управление обратно в пользовательский режим.

В режиме ядра пользовательскому процессу (нашей программе) на время повышается приоритет для возможности работы с файловой подсистемой, периферийным оборудованием, который отсутствует в обычном пользовательском режиме.

---

1. Ввод-вывод в обычной программе обрабатывается через блокирующие системные вызовы операционной системы.
2. Блокирующие вызовы останавливают выполнение программы до завершения соответствующей операции чтения или записи.
3. Операционные системы поддерживают неблокирующие операции ввода-вывода и предоставляют механизмы оповещения о завершении таких операций

файла к чтению/записи или о том, что получена информация по сети, наша задача сужается до своевременного реагирования на такое информирование. Если файл готов для чтения (и очевидно нам он очень нужен, раз мы "подписались" на него), нам нужно приступить к его чтению. Таких файлов и ответов по сети может быть очень много, а значит нам нужно как-то самостоятельно переключать поток выполнения нашей программы согласно нашим нуждам и сообщениям от операционной системы. Нам нужно управлять потоком выполнения, переключать выполнение.

Не успели толком решить одну проблему, как обозначили другую. Но, в отличие от системных вызовов и механизмов контроля ОС над IO операциями, переключение потока выполнения — это самая простая часть в головоломке асинхронного программирования.

Это все, что нам нужно для реализации эффективного исполнения программы. Эффективного с точки зрения скорости выполнения за счет минимизации простоев на операциях ввода-вывода. При этом, очевидно, если блокирующих IO операций нет в программе, повысить ее производительность за счет асинхронного подхода не выйдет.
​​​​​​​Тем не менее, асинхронное программирование как подход и асинхронные библиотеки в качестве инструментов могут применяться и для расчетных задач со множеством оговорок в целях планирования и распределения выполнения.

---
