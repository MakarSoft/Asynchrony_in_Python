# Нам надо поймать 9 рыб
# Если бы у нас было 9 рыбаков и у каждого
# была удочка, то можно было бы воспользоваться многопоточностью
# Создаём пул потоков, каждый поток — отдельный рыбак.
# Общее время выполнения программы не выше, чем максимальная
# длительность работы отдельного рыбака (длительность клёва).
# Но большую часть времени каждый поток ничего не делает,
# только спит (ждёт пока клюнет).
#
# Решение кажется избыточным и является избыточным.

from time import sleep, perf_counter
from itertools import count
from random import randrange
from concurrent.futures import ThreadPoolExecutor

N_FISH: int = 9    # количество рыб

total_count = count(1)


class Fisherman:
    """ Рыбак """

    def __init__(self, name: str = "") -> None:
        self.name = name

    def get(self):
        # имитируем ожидание клева
        sleep(randrange(1, 11))
        print(
            f"\n{self.name} поймал одну, "
            f"[Всего поймано: {next(total_count)}]"
        )


def main(
    n_fish: int = N_FISH
) -> None:
    # создаем рыбаков из расчета по рыбаку на рыбу
    n_men = n_fish
    fishermen = [Fisherman(f"Рыбак_№{i}") for i in range(1, n_men+1)]
    with ThreadPoolExecutor(max_workers=n_men) as executer:
        for f_man in fishermen:
            executer.submit(f_man.get)


if __name__ == "__main__":
    start_time = perf_counter()
    main()
    print(f"total time {perf_counter() - start_time}")

# Как добиться такой же производительности, используя только
# один поток программы?
# Как реализовать сценарий: один рыбак с 9 удочками?
# Что нужно написать в этом коде, чтобы только один поток справился
# с этой задачей за время не больше 10 секунд
# Возможно ли это без модификации класса Fisherman и что конкретно нам мешает?
#
# Конкретно здесь нам мешает блокирующая функция sleep().
# Это на ней мы каждый раз спотыкаемся. Поток выполнения блокируется
# и ждет. Гроссмейстер завис, ожидая ход шахматиста, одновременная
# игра остановилась. Бармен вцепился в кружку и ждет, пока кофемашина
# ее наполнит. Производительность встала. Ждем.
#
# Никакого волшебного способа не блокироваться на блокирующей
# функции/методе нет. Единственный вариант — не использовать,
# не вызывать блокирующую функцию вовсе.
# В нашем случае просто нельзя использовать sleep(). Но как тогда
# переписать код, чтобы добиться ровно такого же поведения, но без
# использования блокирующей функции sleep?
# Как сделать ожидание без ожидания?
#
# Прежде чем пытаться ответить на эти вопросы, давайте вспомним, что
# вообще происходит при вызове sleep() с точки зрения работы операционной
# системы.
# При вызове sleep, ОС записывает текущее время остановки потока и помечает
# поток как временно заблокированный, а также запоминает текущее состояние
# потока, чтобы после ожидания времени блокировки восстановить сохраненное
# состояние и продолжить его выполнение. Планировщик операционной системы
# помещает его в список ожидания и освобождает процессорные ресурсы для других
# задач. Планировщик затем использует таймеры, прерывания или другие механизмы
# контроля времени, чтобы определить, когда поток должен быть возобновлен.
# Когда наступает время возобновления, планировщик активирует поток и снова
# назначает ему небольшой интервал времени доступа к процессору для продолжения
# выполнения. Именно многозадачность операционной системы и способность
# конкурентного выполнения потоков позволяет нам поймать 9 рыб 9-ю потоками за
# 10 секунд. Решая задачу используя потоки мы делегировали большую часть работы
# операционной системе. Но пытаясь решить задачу одним потоком делегировать
# некому. Придется реализовывать конкурентную (а точнее кооперативную)
# многозадачность самостоятельно, организовав собственный аналог планировщика —
# цикл и алгоритм, позволяющий тянуть только за ту удочку, на которую клюет,
# оставляя без внимания остальные.
