
## Сеанса одновременной игры в шахматы

 - Чтобы сделать сеанс одновременной игры более динамичным и скоротечным, нужен **мастер-гроссмейстер**, который быстро делает ходы и не задерживается у доски каждого игрока.
 - В идеале он должен подходить к игрокам не по кругу, а только в момент, когда игрок завершил свой ход и ожидает ход гроссмейстера. Например, игрок делает ход, поднимает руку, чтобы к нему подошел гроссмейстер. В таком случае мастер не будет тратить время на ожидание хода очередного игрока, а будет только реагировать на события, подходя к каждому только для того, чтобы сделать свой ответный ход. Это действительно будет одновременной игрой, в которой одновременно участвуют несколько игроков.
 - Что еще замечательнее, если мы добавим каждому игроку по гроссмейстеру, общее время игры не изменится. Однако каждый из гроссмейстеров будет большую часть своего драгоценного времени просто ждать ответного хода игрока — это неразумная трата ценного времени мастера на простои

Пример с шахматами хорошо иллюстрирует принципы, которые необходимо соблюдать для эффекта одновременной игры:

1. Гроссмейстер должен быть по-настоящему мастером своего дела, совершать быстрые ходы и не задерживаться долго у доски каждого игрока. **Главный исполнитель не должен блокироваться.**
2. Игроки относительно самостоятельны. Они продолжают обдумывать свои ходы и возможные комбинации даже тогда, когда за их шахматной доской не стоит гроссмейстер. А также могут сделать свой ход до того, как к ним подойдет гроссмейстер. **Часть общей работы делегируется окружению (большую часть работы выполняет операционная система)**. Именно благодаря многозадачности операционных систем возможно повышение эффективности за счет асинхронного программирования (об этом мы еще не раз поговорим).
3. Наибольшая эффективность одновременной игры (наибольшая динамичность, наименьшее общее время игры) возможна в том случае, когда гроссмейстер не ждет хода игроков, а подходит к столу каждого участника только тогда, когда последний уже сделал свой ход. Этого можно добиться либо пригласив настоящих профессионалов (но где их столько найти?), либо изменив порядок подхода гроссмейстера к игроку. Пусть гроссмейстер подходит к игроку только тогда, когда игрок уже сделал свой ход. **Асинхронное выполнение всегда предполагает эффективное управление задачами по событию (по готовности), а для этого используется обработчик (диспетчер) событий, который создается явно или "под капотом" при использовании готовых асинхронных библиотек,** он так и называется цикл **событий.**

## Пример с кофемашинами

 Вам нужно наполнить 3 чашки кофе. Себе и коллегам. При этом у Вас в непосредственной доступности 3 кофемашины. Тогда у Вас несколько вариантов решения задачи:

- Действительно одновременный, **параллельный**. Говорите своим коллегам, что здесь слуг нет. Втроем идете к кофемашинам, подставляете чашки и ждете, пока чашки наполнятся. Ждете... ждете... Ждете втроем, и в конце концов каждый получает полную кружку кофе. Этот вариант решения для такой задачи кажется избыточным даже на интуитивном уровне. И уж точно не улучшит командную атмосферу в офисе.
- **Синхронный** вариант. Берете первую кружку, подставляете под аппарат, ждете пока приготовится кофе и наполнится кружка. Берете вторую кружку и повторяете. Потратите в три раза больше времени, но не будете отвлекать коллег и все так же в конечном итоге получите 3 кружки кофе.
- **Асинхронный** вариант. Берете три кружи, расставляете их по аппаратам и уходите по своим делам (например, идете покупать чипсы или залипаете в телефон), когда слышите сигнал от кофемашин, подходите и забираете наполненные кружки. При этом Вы не сильно больше потратите время, если Вам нужно будет приготовить 5 кружек кофе, если конечно у Вас будет 5 кофемашин.

А что если Вы работаете в кофейне? Большой автоматизированной сети, где Ваша задача всего лишь вовремя подставлять кружки под аппарат и выдавать наполненные кружки в окно выдачи.
У Вас одновременно могут наполняться сразу 5 кружек.
Подставить кружку занимает 2 секунды.
Снять кружку и поставить ее в окно выдачи занимает еще пару секунд. Каждая кружка готовится (наполняется) около 30 секунд.
Заказы приходят неравномерно.
Даже в случае когда у Вас 10 кофемашин для одновременного приготовления 10 чашек, Вы будете простаивать.
Можно добавить еще машины без вреда для производительности. Да, возможно какая-то чашка простоит наполненной и готовой к выдаче на несколько секунд позже, но это не очень важно, если таким образом мы заметно увеличим производительность без необходимости найма еще одного работника.

---

 
 В обоих примерах для создания высокой производительности одного единственного исполнителя обязательно требуется:

1. Организация цикличного событийного выполнения. Что-то быстро сделал, взял следующее. Сделал ход, переходи к следующему игроку. Поставил чашку, бери и ставь другую.
2. Отсутствие блокировки на текущем выполнении. Делай ход быстро и не жди ответного хода игрока. Ставь чашку и не жди пока она наполнится.
3. Среда окружения может выполнять основную работу и позволяет делегировать это выполнение. У нас под рукой 10 кофемашин, только подставляй чашки. В комнате много игроков-шахматистов, которые думают над каждым ходом и делают свой ход, только успевай делать ответный ход.

---

>Асинхронное программирование — концепция программирования, которая заключается в том, что результат выполнения функции доступен не сразу, а через некоторое время в виде некоторого асинхронного (нарушающего обычный порядок выполнения) вызова. В отличие от синхронного программирования, где компьютер выполняет инструкции последовательно и ожидает завершения системных операций (обращение к устройствам ввода-вывода, жесткому диску, сетевой запрос) блокируя следующие операции в потоке выполнения, в асинхронном программировании длительные операции запускаются без ожидания их завершения и не блокируя дальнейшее выполнение программы.
[wikipedia](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)


Асинхронное программирование — это....

> концепция, позволяющая выполнять длительную задачу в фоновом режиме отдельно от главного приложения. И система не блокируется в ожидании завершения этой задачи, а может заниматься другими вещами, не зависящими от ее исхода. Затем, по завершении задачи, мы получим уведомление о том, что она все сделала, и сможем обработать результат.
/Asyncio и конкурентное программирование на Python. Мэттью Фаулер./

> общее название для стиля программирования, при котором результат работы функции приходит не сразу после вызова, а когда-нибудь потом.

> концепция программирования, при которой результат выполнения функции доступен спустя некоторое время в виде асинхронного (нарушающего стандартный порядок выполнения) вызова. Запуск длительных операций происходит без ожидания их завершения и не блокирует дальнейшее выполнение программы.

> особенность современных языков программирования, которая позволяет выполнять операции, не дожидаясь их завершения.

> вид программирования, позволяющий вынести выполняемые задачи отдельными блоками кода. Применяется в сервисах, где предыдущее действие тормозит следующее. При использовании асинхронности, код убирает операцию, блокирующую следующие действия.


---

Понятие не ограничивает и не определяет те средства, которые и обеспечивают асинхронное выполнение. Всего-лишь декларируется не блокирование потока выполнения и возможность получения результата в будущем. Но этим условиям частично соответствует и многопоточное программирование. Операции ввода-вывода могут выполняться вспомогательными потоками, пока главный поток может выполнять свою задачу без блокирования на операциях ввода-вывода, которые он делегировал дочерним потокам, а затем обработать результаты выполнения дочерних потоков. Тоже самое с процессами. Поэтому уточним понятие асинхронного программирования, подчеркнув конкретную реализацию.

Асинхронное программирование — концепция программирования, позволяющая выполнять **несколько задач ввода-вывода одним потоком одного процесса без блокирования потока выполнения на ожидания завершения таких задач**.
Асинхронное программирование позволяет эффективнее использовать время, освобождая поток для выполнения других задач во время ожидания завершения операций ввода-вывода.

Здесь и далее мы будем рассматривать реализацию асинхронных программ именно через использование одного главного потока и одного процесса. А эффективность асинхронного выполнения будем показывать через уменьшение времени блокирующих ожиданий. Асинхронный подход всего-лишь уменьшает время простоя, но это качество позволяет добиться впечатляющих результатов.

---

Если Вы уже знакомы с модулем **concurrent.futures** или классом **Pool** из модуля **multiprocessing**, использовали объекты **Future**, **AsyncResult** или методы обработки с "асинхронным" названием (`map_async`, `apply_async` и т.д.), то, фактически, уже создавали асинхронные программы, если рассматривать классические определения.
Мало того, некоторые ранние асинхронные фреймворки и драйверы "под капотом" использовали потоки для эффективного выполнения операций ввода-вывода. В документации, в электронных справочниках по языкам или операционным системам нередко асинхронное выполнение включает использование нескольких потоков и/или процессов. В общем, не путайтесь в понятиях.
Под асинхронным выполнением часто подразумевают **неупорядоченный результат, отложенный результат без блокирования выполнения главного потока без учета как именно и за счет чего это реализовано**.


---

**Кооперативная многозадачность (cooperative multitasking)** — это...

>техника конкурентного выполнения программ, в которой обязанность передачи управления перекладывается на саму программу. Преимущество кооперативной многозадачности заключается в большей надежности и предопределенности выполнения программ, так как при таком подходе программа сама контролирует последовательность выполнения задач.

>вид многозадачности, при котором операционная система не инициирует переключение контекста с запущенного процесса на другой процесс. Вместо этого, чтобы запускать несколько приложений одновременно, процессы добровольно передают управление периодически или когда простаивают или логически блокируются. Этот тип многозадачности называется совместным, потому что все программы должны взаимодействовать, чтобы схема планирования работала.

>тип многозадачности, при котором фоновые задачи выполняются только во время простоя основного процесса и только в том случае, если на это получено разрешение основного процесса.

>тип многозадачности, при котором каждая задача явно передает управление другим задачам, когда она заканчивает свою работу или достигает точки синхронизации. В этом подходе каждая задача должна "сотрудничать" с другими задачами, чтобы обеспечить справедливое распределение ресурсов и позволить другим задачам выполняться.

Несмотря на некоторые отличия во всех этих вариантах определений, можно легко выделить основную отличительную черту, разделяющую понятия **конкурентного** и **кооперативного выполнения**. Понятие определяет ответ на вопрос: **кто управляет задачами и как эти задачи спроектированы для возможности взаимодействия**.

Если мы сами в своей программе определяем моменты переключения, организуем диспетчер задач, назначая условия и определенные точки возврата управления, соответствующим образом оформляем задачи, то это — **кооперативная многозадачность**. Если мы никак не контролируем порядок выполнения задач, всю работу перекладываем на операционную систему, делегируя все на работу ее планировщика, то это — **конкурентная многозадачность**.

**Определения выше не претендуют на академическую точность, но точно позволяют понять суть различия.**
