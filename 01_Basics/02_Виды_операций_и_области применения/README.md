Как не существует универсального лекарства против всех болезней, так не существует универсальной концепции для эффективного решения любых задач в программировании. Для каждого типа задач подходит свой инструмент.

Как Вы знаете, любое выполнение программы — это последовательное выполнение инструкций на процессоре. Инструкции арифметики, логики, сравнения выполняются очень быстро. Однако в процессе выполнения процессору приходится также  обращаться к внешним устройствам — оперативной памяти, жесткому диску, устройствам ввода-вывода. Все они работают очень медленно с точки зрения процессора, что приводит к его простаиванию.

С этой точки зрения все задачи, которые выполняет программный код, разделяются на два типа:

задачи, большую часть времени нагружающие центральный процессор. Все виды расчетных операций, сравнения, преобразования, так называемые "числодробилки". Скорость выполнения таких задач прямо зависит от производительности процессора. Их так и называют CPU-bound операции (операции, зависящие, привязанные к ЦПУ);

не расчетные задачи, которые вместо интенсивной работы на процессоре, занимаются другими вещами. И спектр таких задач очень широк: обращения/запросы/чтение/запись к внешним устройствам и контроллерам, работа с файловой подсистемой, работа с базами данных, работа с устройствами хранения информации, сетевые запросы. В общем, все остальные задачи, скорость выполнения которых определяется общим временем ожидания выполнения операций чтения/записи, которая в свою очередь складывается из пропускной способности канала, производительности шины, отзывчивости внешнего устройства, т.е. зависит от внешней относительно процессора подсистемы ввода-вывода. Соответственно, такие задачи называют IO-bound операции (зависящие, привязанные к Input Output - к вводу-выводу).
Здесь уже можно возразить, сказав что работа с процессором, как и собственно расчетные операции тоже включает в себя чтение и запись данных в кэш процессора. Так в чем разница? Разница в скорости. Ошеломительная разница в скорости.

Для  наглядности сравнения посмотрим на таблицу чтения данных с различных устройств.

Устройство	Тактов ЦП	Наглядная временная шкала
Кэш L1	3	3 секунды
Кэш L2	14	14 секунд
ОЗУ	250	250 секунд
HDD	41 000 000	1.3 года
Сеть	240 000 000	7.6 лет
Процессор с гигагерцовой частой за одну секунду выполнит больше 300 миллионов операций чтения из кэша первого уровня, и за ту же секунду выполнятся всего 4 запроса по сети. Правая колонка позволяет наглядно сравнить операции чтения в привычной человеку системе координат. Как видим, здесь есть довольно резкая граница: работа процессора с кэшем и оперативной памятью и все остальное.

На практике большинство задач реальной бизнес логики, особенно с учетом развития микросервисной архитектуры и распределенных систем, выполняют преимущественно IO-bound операции. Приложения все больше зависят от обмена данными между различными компонентами, а общая производительность и отзывчивость определяются эффективностью решения проблем, связанных с обменом по сети, эффективностью работы с базами данных и т.п. Соответственно, эффективное управление этими операциями является критически важным аспектом проектирования программного обеспечения.

Глядя на таблицу вообще не хочется самому выполнять медленные IO операции, которые тормозят поток выполнения и блокируют его на время ожидания их завершения. Вот было бы здорово работать без ожиданий, делегируя все IO операции кому-нибудь другому, кто с этим хорошо справляется, а самим взаимодействовать только с процессором и оперативной памятью, своевременно обрабатывая результаты IO операций по мере их готовности.
