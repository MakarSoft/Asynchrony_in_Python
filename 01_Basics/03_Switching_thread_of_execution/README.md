
Ранее мы дали определение блокирующего метода или функции, к которым отнесли только те задачи, которые надолго блокируют работу программы, ожидая завершения выполнения длительных IO операций. И в контексте темы это верно. Но по своей природе любая функция является блокирующей. Когда поток вызывает функцию, он "проваливается" в нее и выполняет ее инструкции. Пока не выполнит return или пока не поднимется исключение, поток выполнения будет заблокирован этой функцией.

Какие-то методы или функции очень быстро выполняются и мы не замечаем никакого блокирования в работе. Но если функция выполняется очень долго или вовсе имеет бесконечный цикл, то эта ловушка для нашего потока становится непреодолимой.

В примере ниже мы никогда не выполним все три задачи:
```Python
def task_1():
    for _ in range(3):
        print("задача 1")


def task_2():
    while True:
        print("задача 2")


def task_3():
    for _ in range(2):
        print("задача 3")


task_1()
task_2()
task_3()
```
Сначала наш поток выполнит полностью функцию task_1. Затем, закончив с ней, вызовет вторую функцию. И при выполнении task_2 наш поток навсегда будет заблокирован в бесконечном цикле while True. При этом нет ни одного шанса, чтобы наш поток выполнения как-то "выпрыгнул" из второй функции и начал выполнять третью task_3.

Но что, если надо здесь и сейчас одновременно выполнять все три задачи?
Одновременно — точно никак. Но хотя бы конкурентно, сохраняя иллюзию одновременности. И давайте сразу усложним задачи, сделав всех их с бесконечными циклами:

```Python
def task_1():
    while True:
        print("задача 1")
    return


def task_2():
    while True:
        print("задача 2")
    return


def task_3():
    while True:
        print("задача 3")
    return


task_1()
task_2()
task_3()
```
А также явно добавим return (как Вы знаете return None вызывается автоматически, если в функции нет явного определения return с другим значением).

Для того, чтобы мы могли попеременно выполнять задачи, нам нужна возможность, которая позволяла бы ограничивать выполнение одной задачи и возвращать управление от этой задачи обратно. Т.е. наш поток выполнения должен работать в следующей последовательности:

вызываем функцию и "запрыгиваем" в нее;
работаем над задачей, над какой-то ее частью;
"выходим" из задачи, при этом задача сохраняет свое состояние;
вызываем другую функцию.... и так далее.
А когда вновь возвращаемся к выполнению предыдущей задачи, то выполняем ее не с начала, а "запрыгиваем" в конкретное место, откуда "вышли" в прошлый раз.

В python есть сущность, которая позволяет так делать. Это – генераторы. Точнее функции-генераторы. Заменим return оператором yield, расставив их в тех точках, где хотим обеспечить возврат управления нашему потоку. Тогда наши функции превращаются в функции-генераторы, а yield наделяет их совершенно уникальными свойствами, одно из которых – возврат управления, определяет саму возможность кооперативного выполнения и асинхронного программирования.

Итак, применяем магию:
1. Расставляем yield в точках, где хотим возвращать управление обратно нашему потоку. Выполнил один цикл в задаче - выйди и получи возможность выполнить цикл в другой задаче.
```Python
def task_1():
    while True:
        print("задача 1")
        yield


def task_2():
    while True:
        print("задача 2")
        yield


def task_3():
    while True:
        print("задача 3")
        yield
```
 2. Генератор –  это не совсем привычная функция. Вызов генератора возвращает объект генератора, а не результат его выполнения. Поэтому сначала создаем объекты генератора, а уже затем работаем с ними:
```Python
g1 = task_1()
g2 = task_2()
g3 = task_3()
```
3. Теперь создаем простейший диспетчер задач – цикл, в котором используем известный метод обхода генератора  next:
```Python
for g in (g1, g2, g3):
    next(g)
```
Запускаем пример и результат готов!

```
задача 1
задача 2
задача 3
```
Не смотря на блокирующие бесконечные циклы, мы смогли выполнить по одному циклу в каждой функции task.

Здесь next и yield можно и нужно рассматривать в первую очередь как точки переключения управления. yield возвращает управление в то место, откуда был вызван next. А вызов next, в свою очередь передает управление в указанный объект генератора. И это очень важная деталь, настолько важная, что генераторы надо рассматривать не столько как источники каких-то данных, а, в первую очередь, как инструмент передачи контроля выполнения из функций-генераторов в диспетчер задач и обратно.

---

Диспетчер задач можно написать с ограниченным количеством запусков, а можно обеспечить и бесконечное кооперативное выполнение задач, используя различные коллекции и структуры данных. Например, используя список, можно организовать цикл поочередного выполнения каждой задачи списка в три простых шага:

- Извлекаем задачу из списка `tasks.pop(0)`.
- Выполняем ее, используя `next`. Поток выполнения исполняет инструкции задачи пока не встретит `yield`. В задаче вызывается yield и поток выполнения возвращается обратно в цикл задач.
- Возвращаем задачу обратно в список.


В коде это выглядит так:

```Python
import time

def task_1():
    while True:
        print("задача 1")
        yield

def task_2():
    while True:
        print("задача 2")
        yield

def task_3():
    while True:
        print("задача 3")
        yield

g1 = task_1()
g2 = task_2()
g3 = task_3()
tasks = [g1, g2, g3]

# выполняем задачи до тех пор, пока они есть в списке
while tasks:
    time.sleep(0.2)  #  импортируем sleep из модуля time чтобы удобнее наблюдать за результатом
    task = tasks.pop(0)  # извлекаем задачу из списка
    next(task)  # выполняем задачу
    tasks.append(task)  # добавляем задачу обратно в список задач
```
задача 1
задача 2
задача 3
задача 1
задача 2
задача 3
... и т.д.

Наш диспетчер задач немного усложняется, если генераторы выполняют конечную работу и имеют ограниченный срок жизни. В таком случае приходится обрабатывать исключение `StopIteration`, которое возбуждается при завершении работы генератора при вызове `next`. Кроме этого завершенные генераторы с таким исключением необходимо удалять из списка задач, поддерживая актуальность списка. Для этих целей удобно использовать конструкцию:
```Python
try:
    # пробуем что-то сделать
except:
    # перехватываем и обрабатываем исключение
else:
    # этот блок выполняется только если блок try выполнился без исключений
```
В примере ниже все три функции-генераторы имеют разное количество итераций циклов, но наш обновленный диспетчер задач успешно обходит их всех.

```Python
from time import sleep


def task_1():
    for i in range(1, 5):
        print("число ->", i)
        yield


def task_2():
    for s in "№;%:?*":
        print("символ ->", s)
        yield


def task_3():
    for v in "абв":
        print("буква ->", v)
        yield


g1 = task_1()
g2 = task_2()
g3 = task_3()

tasks = [g1, g2, g3]

while tasks:
    sleep(0.2)
    task = tasks.pop(0)
    try:
        next(task)  # пробуем получить новое значение от генератора
    except StopIteration:
        pass  # пропускаем цикл с исключением
    else:
        tasks.append(task)  # возвращаем генератор в список, если он не возбудил StopIteration
```
```
число -> 1
символ -> №
буква -> а
число -> 2
символ -> ;
буква -> б
число -> 3
символ -> %
буква -> в
число -> 4
символ -> :
символ -> ?
символ -> *
```

Для нашего диспетчера задач список подходит не самым лучшим образом, рациональнее использовать двухстороннюю очередь deque из прекрасного модуля коллекций collections. Эффективное добавление и извлечение элемента с обоих концов очереди за O(1) — то что нам нужно! Тогда предыдущий пример будет выглядеть так:

```Python
from time import sleep
from collections import deque


tasks = deque((g1, g2, g3))  # инициализируем очередь используя кортеж генераторов

while tasks:
    sleep(0.2)
    task = tasks.popleft()  # извлекаем задачу с левого конца очереди
    try:
        next(task)
    except StopIteration:
        pass
    else:
        tasks.append(task)  # добавляем задачу в правый конец очереди
```
Примечание 1. В настоящем event loop библиотеки asyncio используется как раз двухсторонняя очередь deque


---

Во всех наших примерах мы сами оператором `yield` указываем конкретные точки переключения управления, а значит реализуем кооперативную многозадачность.

>Кооперативная многозадачность (cooperative multitasking) – это техника конкурентного выполнения программ, в которой обязанность передачи управления перекладывается на саму программу. При кооперативной многозадачности мы сами в своей программе определяем моменты переключения, организуем диспетчер задач, назначая условия и определенные точки возврата управления, соответствующим образом оформляем задачи.

Чтобы магия заработала, организовать переключение потока управления не достаточно, второе обязательное условие – создание диспетчера задач, который бы хранил перечень задач, следил за их актуальностью, "подкидывал" на исполнение наиболее приоритетные задачи и т.д.

Диспетчер задач может быть очень простым, как в наших примерах. Просто цикл с организацией простой стратегии `Round-robin`. Эдакая карусель задач по кругу без приоритета. А может включать в себя динамическое изменение приоритета задач, сложное планирование и т.п. Тогда диспетчер задач начинает напоминать планировщик операционной системы, т.к. реализует некоторые его свойства. Но в основе своей остается циклом. А потому диспетчер задач называется `событийным циклом` (или `циклом событий` или `event loop`). Событийным, потому что **планирование работы задач основано на событиях** – изменениях состояния задач или некоторых действий операционной системы.

использование генераторов с их волшебным `yield` и организация диспетчера задач в виде планировщика с применением некоторых механизмов операционной системы уже позволяют написать полноценную асинхронную программу.

Примечание 1. Хорошее видео про различные стратегии планирования операционных систем, включая `Round-robin`: Алгоритмы планирования, на познавательном ютюб канале [Dr Bragin](https://www.youtube.com/@abragin).
